<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<title>Foghorn</title>
	<link rel="stylesheet" href="/styles.css" />
	<!-- Ajv JSON Schema validator for client-side config checks -->
	<script src="https://cdn.jsdelivr.net/npm/ajv@8.12.0/dist/ajv7.min.js"></script>
	<!-- js-yaml for parsing YAML config in the browser -->
	<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
	<script>
		(function () {
			'use strict';
			var root = document.documentElement;
			var stored = null;
			try {
				stored = window.localStorage ? localStorage.getItem('foghorn-theme') : null;
			} catch (e) {
				stored = null;
			}
			var initial = stored === 'light' || stored === 'dark' ? stored : 'dark';
			root.setAttribute('data-theme', initial);
		})();
	</script>
</head>

<body>
	<header class="fh-header">
		<div class="fh-header-inner">
			<div class="fh-header-main">
				<!-- Logo image switches based on theme: transparent-logo.png (light), transparent-white-logo.png (dark) -->
				<img src="/transparent-white-logo.png" alt="Foghorn logo" class="fh-logo" id="fh-logo" />
				<div class="fh-title-block">
					<h1 class="fh-title">Foghorn</h1>
					<p class="fh-subtitle">Runtime statistics and configuration</p>
				</div>
				<div class="fh-theme-toggle" role="radiogroup" aria-label="Color theme">
					<button id="btn-theme-dark" class="fh-theme-btn fh-theme-btn-active" type="button" role="radio"
						aria-checked="true">
						Dark
					</button>
					<button id="btn-theme-light" class="fh-theme-btn" type="button" role="radio" aria-checked="false">
						Light
					</button>
				</div>
			</div>
		</div>
	</header>
	<div class="fh-tabs" role="tablist" aria-label="Pages">
		<button id="btn-tab-stats" class="fh-theme-btn fh-theme-btn-active" type="button" role="tab"
			aria-selected="true">
			Stats
		</button>
		<button id="btn-tab-edit" class="fh-theme-btn" type="button" role="tab" aria-selected="false">
			Advanced/Config
		</button>
		<button id="btn-tab-docker" class="fh-theme-btn" type="button" role="tab" aria-selected="false">
			Docker Hosts
		</button>
	</div>
	<main class="fh-main" id="page2">
		<section class="fh-pane fh-pane-left">
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">Statistics</h2>
				<p class="fh-pane-help">Live snapshot from <code>/api/v1/stats</code>.</p>
			</div>
			<div id="stats-groups" class="fh-stats-groups">
			</div>
		</section>

		<section class="fh-pane fh-pane-right">
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">More Statistics</h2>
			</div>
			<div id="stats-groups-right" class="fh-stats-groups">
				<!-- Filled by JavaScript: e.g. Top A Domains -->
			</div>
		</section>
	</main>
	<main class="fh-main" id="page1">

		<section class="fh-pane fh-pane-left">
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">Raw JSON Stats</h2>
				<p class="fh-pane-help"></p>
			</div>
			<div id="stats-groups" class="fh-stats-groups">
				<!-- Filled by JavaScript -->
			</div>
			<div class="fh-stats-group">
				<h3 class="fh-stats-group-title">Raw stats JSON</h3>
				<pre id="stats-raw" class="fh-pre fh-pre-compact">Loading statistics...</pre>
			</div>
		</section>

		<section class="fh-pane fh-pane-right">
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">Configuration</h2>
				<div class="fh-config-actions" id="config-actions-view">
					<button id="btn-edit" class="fh-btn" type="button">Edit Config</button>
				</div>
				<div class="fh-config-actions fh-config-actions-edit" id="config-actions-edit" hidden>
					<button id="btn-cancel" class="fh-btn fh-btn-secondary" type="button">Cancel</button>
					<button id="btn-save" class="fh-btn fh-btn-primary" type="button">Save</button>
				</div>
			</div>
			<div class="fh-warning" id="config-warning">
				<strong>Warning:</strong> Saving will overwrite <code>config.yaml</code>, then after a brief
				delay send SIGHUP to the main process. Changes take effect after the server restarts;
				SIGUSR1/SIGUSR2 only notify plugins and may reset statistics when configured.
			</div>

			<div id="config-messages" class="fh-messages" aria-live="polite"></div>

			<div id="config-view-container">
				<pre id="config-output" class="fh-pre">Loading configuration...</pre>
			</div>

			<div id="config-edit-container" hidden>
				<textarea id="config-editor" class="fh-textarea" spellcheck="false"></textarea>
			</div>
		</section>
	</main>
	<main class="fh-main fh-main-docker" id="page-docker">

		<section class="fh-pane fh-pane-docker">
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">Docker Hosts</h2>
				<p class="fh-pane-help">Containers and hosts discovered by the DockerHosts plugin.</p>
			</div>
			<div id="docker-hosts-summary" class="fh-stats-groups"></div>
			<div class="fh-pane-header">
				<h2 class="fh-pane-title">Containers</h2>
				<p class="fh-pane-help">Live snapshot from <code>/api/v1/plugins/docker/docker_hosts</code>.</p>
			</div>
			<div class="fh-docker-controls">
				<label class="fh-toggle-hash">
					<input type="checkbox" id="docker-show-hash" />
					<span>Show hash-like hostnames (IDs / pins)</span>
				</label>
			</div>
			<div id="docker-hosts-table" class="fh-stats-groups"></div>
		</section>
	</main>

	<footer class="fh-footer">
		Foghorn&copy; 2025, Zack Allison. GitHub:
		<a href="https://github.com/zallison/foghorn">https://github.com/zallison/foghorn</a>
		&mdash; Open Source Software: MIT Licence
	</footer>

	<script>
		(function () {
			'use strict';

			var root = document.documentElement;
			var logoEl = document.getElementById('fh-logo');
			var statsRawEl = document.getElementById('stats-raw');
			var statsGroupsEl = document.getElementById('stats-groups');
			var statsGroupsRightEl = document.getElementById('stats-groups-right');
			var configOutputEl = document.getElementById('config-output');
			var configEditorEl = document.getElementById('config-editor');
			var configViewContainer = document.getElementById('config-view-container');
			var configEditContainer = document.getElementById('config-edit-container');
			var msgEl = document.getElementById('config-messages');
			var dockerShowHashEl = document.getElementById('docker-show-hash');
			if (msgEl) {
				msgEl.style.display = 'none';
			}
			var warningEl = document.getElementById('config-warning');
			if (warningEl) {
				warningEl.style.display = 'none';
			}

			var btnDisk = document.getElementById('btn-config-disk');
			var btnEdit = document.getElementById('btn-edit');
			var btnCancel = document.getElementById('btn-cancel');
			var btnSave = document.getElementById('btn-save');
			var actionsView = document.getElementById('config-actions-view');
			var actionsEdit = document.getElementById('config-actions-edit');
			var btnThemeDark = document.getElementById('btn-theme-dark');
			var btnThemeLight = document.getElementById('btn-theme-light');
			var page1 = document.getElementById('page1');
			var page2 = document.getElementById('page2');
			var pageDocker = document.getElementById('page-docker');
			var btnTabStats = document.getElementById('btn-tab-stats');
			var btnTabEdit = document.getElementById('btn-tab-edit');
			var btnTabDocker = document.getElementById('btn-tab-docker');
			// Effective instance name for the DockerHosts plugin as configured in config/config.yaml.
			var DOCKER_HOSTS_PLUGIN_NAME = 'docker';

			var currentSource = 'disk'; // 'disk' only
			var lastDiskConfigObj = null;
			var lastDiskRawYaml = null;
			var isEditing = false;

			// Client-side JSON Schema validation (Ajv from CDN). We prefer window.ajv7.Ajv
			// when available, falling back to window.Ajv when present. When Ajv is
			// missing, validation becomes a no-op and server-side validation still
			// enforces correctness on save/startup.
			var AjvCtor = (window.ajv7 && window.ajv7.Ajv) || window.Ajv || null;
			var configSchemaValidator = null;

			var STATS_TOOLTIPS = {
				total_queries: 'Total DNS queries handled since the collector started or was last reset.',
				cache_hits: 'Queries answered directly from the cache.',
				cache_misses: 'Queries that required contacting upstream servers.',
				cache_null: 'Responses generated directly by plugins before cache or upstream lookup.',
				cache_deny_pre: 'Pre-plugin deny decisions that bypassed cache (e.g., filtering plugins).',
				cache_override_pre: 'Pre-plugin overrides that bypassed cache (e.g., synthetic responses from plugins).',
				min_ms: 'Fastest observed query latency in milliseconds.',
				max_ms: 'Slowest observed query latency in milliseconds.',
				avg_ms: 'Average (mean) query latency in milliseconds.',
				p50_ms: 'Median (50th percentile) query latency in milliseconds.',
				p90_ms: '90th percentile query latency in milliseconds.',
				p99_ms: '99th percentile query latency in milliseconds.',
				load_1m: 'System load average over the last 1 minute.',
				load_5m: 'System load average over the last 5 minutes.',
				load_15m: 'System load average over the last 15 minutes.',
				dnssec_secure: 'Responses that validated successfully against DNSSEC trust anchors (secure).',
				dnssec_ext_secure: 'Responses treated as DNSSEC-secure based on extended upstream signals (for example, AD bit).',
				dnssec_unsigned: 'Responses from zones that are not signed with DNSSEC (unsigned but not an error).',
				dnssec_bogus: 'Responses that failed DNSSEC validation (bogus).',
				dnssec_indeterminate: 'Responses where DNSSEC status could not be determined (indeterminate).',
			};
			var lastDiskConfigObj = null;
			var lastDiskRawYaml = null;
			var isEditing = false;

			// Client-side JSON Schema validation (Ajv from CDN). We prefer window.ajv7.Ajv
			// when available, falling back to window.Ajv when present. When Ajv is
			// missing, validation becomes a no-op and server-side validation still
			// enforces correctness on save/startup.
			var AjvCtor = (window.ajv7 && window.ajv7.Ajv) || window.Ajv || null;
			var configSchemaValidator = null;

			var STATS_TOOLTIPS = {
				total_queries: 'Total DNS queries handled since the collector started or was last reset.',
				cache_hits: 'Queries answered directly from the cache.',
				cache_misses: 'Queries that required contacting upstream servers.',
				cache_null: 'Responses generated directly by plugins before cache or upstream lookup.',
				cache_deny_pre: 'Pre-plugin deny decisions that bypassed cache (e.g., filtering plugins).',
				cache_override_pre: 'Pre-plugin overrides that bypassed cache (e.g., synthetic responses from plugins).',
				min_ms: 'Fastest observed query latency in milliseconds.',
				max_ms: 'Slowest observed query latency in milliseconds.',
				avg_ms: 'Average (mean) query latency in milliseconds.',
				p50_ms: 'Median (50th percentile) query latency in milliseconds.',
				p90_ms: '90th percentile query latency in milliseconds.',
				p99_ms: '99th percentile query latency in milliseconds.',
				load_1m: 'System load average over the last 1 minute.',
				load_5m: 'System load average over the last 5 minutes.',
				load_15m: 'System load average over the last 15 minutes.',
				dnssec_secure: 'Responses that validated successfully against DNSSEC trust anchors (secure).',
				dnssec_ext_secure: 'Responses treated as DNSSEC-secure based on extended upstream signals (for example, AD bit).',
				dnssec_unsigned: 'Responses from zones that are not signed with DNSSEC (unsigned but not an error).',
				dnssec_bogus: 'Responses that failed DNSSEC validation (bogus).',
				dnssec_indeterminate: 'Responses where DNSSEC status could not be determined (indeterminate).',
			};

			function setMessage(text, level) {
				if (!msgEl) {
					return;
				}
				msgEl.textContent = text || '';
				msgEl.className = 'fh-messages';
				if (!text) {
					msgEl.style.display = 'none';
					return;
				}
				msgEl.style.display = 'block';
				if (level === 'error') {
					msgEl.classList.add('fh-messages-error');
				} else if (level === 'success') {
					msgEl.classList.add('fh-messages-success');
				} else {
					msgEl.classList.add('fh-messages-info');
				}
			}

			function pretty(obj) {
				try {
					return JSON.stringify(obj, null, 2);
				} catch (e) {
					return String(obj);
				}
			}

			function fetchJson(path) {
				return fetch(path, { cache: 'no-store' }).then(function (resp) {
					if (!resp.ok) {
						throw new Error('HTTP ' + resp.status + ' from ' + path);
					}
					return resp.json();
				});
			}

			function ensureConfigValidator() {
				if (!AjvCtor) {
					// Ajv not available; skip client-side schema validation.
					return Promise.resolve(null);
				}
				if (configSchemaValidator) {
					return Promise.resolve(configSchemaValidator);
				}
				return fetch('/config-schema.json', { cache: 'no-store' })
					.then(function (resp) {
						if (!resp.ok) {
							throw new Error('HTTP ' + resp.status + ' from /config-schema.json');
						}
						return resp.json();
					})
					.then(function (schema) {
						var ajv = new AjvCtor({ allErrors: true, strict: false, allowUnionTypes: true });
						configSchemaValidator = ajv.compile(schema);
						return configSchemaValidator;
					});
			}

			function validateConfigObjectForEdit(cfg) {
				return ensureConfigValidator().then(function (validator) {
					if (!validator) {
						return;
					}
					var ok = validator(cfg);
					if (ok) {
						return;
					}
					var errors = validator.errors || [];
					var lines = errors.map(function (e) {
						var instPath = e.instancePath || '<root>';
						var msg = e.message || 'validation error';
						var schemaLoc = e.schemaPath || '';
						return instPath + ': ' + msg + (schemaLoc ? ' (schema: ' + schemaLoc + ')' : '');
					});
					throw new Error('Invalid configuration:\n' + lines.join('\n'));
				});
			}

			function formatNumber(value) {
				var n = Number(value);
				if (!isFinite(n)) {
					return String(value);
				}
				var opts = { maximumFractionDigits: 3 };
				if (Math.abs(n) > 100 && n % 1 !== 0) {
					opts.maximumFractionDigits = 0;
				}
				return n.toLocaleString(undefined, opts);
			}

			function getNumberParts(value) {
				var n = Number(value);
				if (!isFinite(n)) {
					return { intPart: String(value), decPart: '' };
				}
				var opts = { maximumFractionDigits: 3 };
				if (Math.abs(n) > 100 && n % 1 !== 0) {
					opts.maximumFractionDigits = 0;
				}
				var text = n.toLocaleString('en-US', opts);
				var dotIndex = text.indexOf('.');
				if (dotIndex === -1) {
					return { intPart: text, decPart: '' };
				}
				return {
					intPart: text.slice(0, dotIndex),
					decPart: text.slice(dotIndex),
				};
			}

			function formatBytes(value) {
				var n = Number(value);
				if (!isFinite(n) || n < 0) {
					return 'â€“';
				}
				var units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
				var idx = 0;
				while (n >= 1024 && idx < units.length - 1) {
					n = n / 1024;
					idx += 1;
				}
				return n.toFixed(idx === 0 ? 0 : 1) + ' ' + units[idx];
			}

			function formatTimestamp(value) {
				if (value == null) {
					return null;
				}
				var date;
				if (typeof value === 'number') {
					date = new Date(value * 1000);
				} else {
					var n = Number(value);
					if (isFinite(n)) {
						date = new Date(n * 1000);
					} else {
						date = new Date(String(value));
					}
				}
				if (isNaN(date.getTime())) {
					return String(value);
				}
				function pad2(num) {
					return num < 10 ? '0' + num : String(num);
				}
				var y = date.getFullYear();
				var m = pad2(date.getMonth() + 1);
				var d = pad2(date.getDate());
				var hh = pad2(date.getHours());
				var mm = pad2(date.getMinutes());
				var ss = pad2(date.getSeconds());
				return y + '-' + m + '-' + d + ' ' + hh + ':' + mm + ':' + ss;
			}

			function formatDurationSeconds(value) {
				if (value == null) {
					return null;
				}
				var n = Number(value);
				if (!isFinite(n) || n < 0) {
					return String(value);
				}
				var total = Math.floor(n);
				var days = Math.floor(total / 86400);
				var rem = total % 86400;
				var hours = Math.floor(rem / 3600);
				rem = rem % 3600;
				var minutes = Math.floor(rem / 60);
				var seconds = rem % 60;
				function pad2(num) {
					return num < 10 ? '0' + num : String(num);
				}
				var hms = pad2(hours) + ':' + pad2(minutes) + ':' + pad2(seconds);
				if (days > 0) {
					return days + 'd ' + hms;
				}
				return hms;
			}

			function clearStatsGroups() {
				while (statsGroupsEl.firstChild) {
					statsGroupsEl.removeChild(statsGroupsEl.firstChild);
				}
				if (statsGroupsRightEl) {
					while (statsGroupsRightEl.firstChild) {
						statsGroupsRightEl.removeChild(statsGroupsRightEl.firstChild);
					}
				}
			}

			function appendDictGroup(title, mapping) {
				if (!mapping || typeof mapping !== 'object') {
					return;
				}
				var keys = Object.keys(mapping);
				if (!keys.length) {
					return;
				}
				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = title;
				group.appendChild(heading);

				var dl = document.createElement('dl');
				dl.className = 'fh-kv-list';

				// For Totals, Query types, and Response codes we sort by value (descending)
				// and then by key name (ascending) to make the highest counters easiest to see.
				var sortByValueDesc =
					title === 'Totals' || title === 'Query types' || title === 'Response codes';

				var entries = keys.map(function (key) {
					var raw = mapping[key];
					var num = Number(raw);
					if (!isFinite(num)) {
						// Treat non-numeric as 0 for ordering but still display original.
						num = 0;
					}
					return { key: key, value: raw, numeric: num };
				});

				if (sortByValueDesc) {
					entries.sort(function (a, b) {
						if (b.numeric === a.numeric) {
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						}
						return b.numeric - a.numeric;
					});
				} else {
					// For Meta, use a fixed display order for key fields and fall back
					// to alphabetical ordering for any remaining keys.
					if (title === 'Meta') {
						// Meta ordering: host (combined row) is injected above via
						// mapping.hostname/version/ip. Within the Meta group we want
						// ip, created_at, uptime, domains, clients, with any other
						// keys alphabetically in the middle.
						var headOrder = ['ip', 'created_at'];
						var tailOrder = ['uptime', 'domains', 'clients'];
						entries.sort(function (a, b) {
							var aHead = headOrder.indexOf(a.key);
							var bHead = headOrder.indexOf(b.key);
							var aTail = tailOrder.indexOf(a.key);
							var bTail = tailOrder.indexOf(b.key);
							// Head keys (hostname, version, ip) always first in fixed order.
							if (aHead !== -1 || bHead !== -1) {
								if (aHead === -1) return 1;
								if (bHead === -1) return -1;
								return aHead - bHead;
							}
							// Tail keys (domains, clients, uptime) always last in fixed order.
							if (aTail !== -1 || bTail !== -1) {
								if (aTail === -1) return -1;
								if (bTail === -1) return 1;
								return aTail - bTail;
							}
							// All other keys go in the middle, sorted alphabetically.
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						});
					} else {
						entries.sort(function (a, b) {
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						});
					}
				}

				if (title === 'Meta') {
					var host = mapping.hostname != null ? String(mapping.hostname) : '';
					var ver = mapping.version != null ? String(mapping.version) : '';
					var ip = mapping.ip != null ? String(mapping.ip) : '';
					if (host || ver) {
						var dtCombined = document.createElement('dt');
						dtCombined.textContent = 'host';
						var ddCombined = document.createElement('dd');
						var text = '';
						if (host) {
							text += host;
						}
						if (ver) {
							if (text) {
								text += ' ';
							}
							text += 'v' + ver;
						}
						ddCombined.textContent = text;
						dl.appendChild(dtCombined);
						dl.appendChild(ddCombined);
					}
				}

				entries.forEach(function (entry) {
					var key = entry.key;
					// Skip individual hostname/version keys in Meta now that we
					// render them as a single combined "host" row. Keep ip as its
					// own row directly beneath.
					if (title === 'Meta' && (key === 'hostname' || key === 'version')) {
						return;
					}
					var dt = document.createElement('dt');
					dt.textContent = key;
					if (Object.prototype.hasOwnProperty.call(STATS_TOOLTIPS, key)) {
						dt.title = STATS_TOOLTIPS[key];
					}
					var dd = document.createElement('dd');
					dd.textContent = formatNumber(entry.value);
					if (dt.title) {
						dd.title = dt.title;
					}
					dl.appendChild(dt);
					dl.appendChild(dd);
				});
				group.appendChild(dl);
				statsGroupsEl.appendChild(group);
			}

			function appendTopListGroup(title, entries, container) {
				if (!entries || !Array.isArray(entries) || !entries.length) {
					return;
				}
				var target = container || statsGroupsEl;
				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = title;
				// Provide a helpful tooltip for any "*Subdomain*" style list so it
				// is clear that the entries are full subdomain qnames.
				if (
					typeof title === 'string' &&
					(title.indexOf('Subdomain') !== -1 || title.indexOf('Sub Domains') !== -1)
				) {
					heading.title = 'Entries are subdomain names (full qnames, for example "www.example.com").';
				}
				group.appendChild(heading);

				var dl = document.createElement('dl');
				dl.className = 'fh-kv-list';

				entries.forEach(function (pair) {
					if (!pair || pair.length < 2) {
						return;
					}
					var key = pair[0];
					var count = pair[1];

					var dt = document.createElement('dt');
					dt.textContent = key;

					var dd = document.createElement('dd');
					dd.textContent = formatNumber(count);

					dl.appendChild(dt);
					dl.appendChild(dd);
				});

				group.appendChild(dl);
				target.appendChild(group);
			}

			function appendUpstreamsGroup(upstreams, upstreamRcodes) {
				if (!upstreams || typeof upstreams !== 'object') {
					return;
				}
				var upstreamIds = Object.keys(upstreams);
				if (!upstreamIds.length) {
					return;
				}

				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Upstreams';
				heading.title = 'Per-upstream totals with breakdown by response code (NOERROR, NXDOMAIN, SERVFAIL, etc.).';
				group.appendChild(heading);

				var table = document.createElement('table');
				table.className = 'fh-table fh-table-upstreams';
				var tbody = document.createElement('tbody');

				// Build sortable rows with pre-computed totals.
				var upstreamRows = [];
				upstreamRcodes = upstreamRcodes || {};

				upstreamIds.forEach(function (upstreamId) {
					var outcomes = upstreams[upstreamId];
					if (!outcomes || typeof outcomes !== 'object') {
						outcomes = {};
					}

					var rcMap = {};
					if (upstreamRcodes && typeof upstreamRcodes === 'object') {
						rcMap = upstreamRcodes[upstreamId] || {};
					}
					var rcodeKeys = Object.keys(rcMap).sort();

					var total = 0;
					if (rcodeKeys.length) {
						rcodeKeys.forEach(function (key) {
							var val = Number(rcMap[key]);
							if (!isFinite(val)) {
								val = 0;
							}
							total += val;
						});
					} else {
						var outcomeKeys = Object.keys(outcomes).sort();
						if (!outcomeKeys.length) {
							return;
						}
						outcomeKeys.forEach(function (key) {
							var val = Number(outcomes[key]);
							if (!isFinite(val)) {
								val = 0;
							}
							total += val;
						});
					}

					upstreamRows.push({
						id: upstreamId,
						outcomes: outcomes,
						rcodes: rcMap,
						rcodeKeys: rcodeKeys,
						total: total,
					});
				});

				// Sort by total count (descending), then by upstream id (ascending).
				upstreamRows.sort(function (a, b) {
					if (b.total === a.total) {
						if (a.id < b.id) return -1;
						if (a.id > b.id) return 1;
						return 0;
					}
					return b.total - a.total;
				});

				upstreamRows.forEach(function (rowData) {
					var upstreamId = rowData.id;
					var total = rowData.total;
					var rcodes = rowData.rcodes || {};
					var rcodeKeys = rowData.rcodeKeys || [];

					// Main row: "upstream", "", "total"
					var mainRow = document.createElement('tr');
					var mainUpstreamCell = document.createElement('td');
					mainUpstreamCell.textContent = upstreamId;
					var mainBlankCell = document.createElement('td');
					mainBlankCell.textContent = '';
					var mainTotalParts = getNumberParts(total);
					var mainTotalIntCell = document.createElement('td');
					mainTotalIntCell.className = 'fh-num-int';
					mainTotalIntCell.textContent = mainTotalParts.intPart;
					var mainTotalDecCell = document.createElement('td');
					mainTotalDecCell.className = 'fh-num-dec';
					mainTotalDecCell.textContent = mainTotalParts.decPart;
					mainRow.appendChild(mainUpstreamCell);
					mainRow.appendChild(mainBlankCell);
					mainRow.appendChild(mainTotalIntCell);
					mainRow.appendChild(mainTotalDecCell);
					tbody.appendChild(mainRow);

					// Detail rows: "", rcode or outcome, count. Prefer rcodes
					// when available, fall back to outcomes otherwise.
					if (rcodeKeys.length > 1) {
						// Sort rcodes (excluding NOERROR) by count descending, then name.
						var rcodeEntries = rcodeKeys
							.filter(function (key) {
								return key !== 'NOERROR';
							})
							.map(function (key) {
								var num = Number(rcodes[key]);
								if (!isFinite(num)) {
									num = 0;
								}
								return { key: key, value: rcodes[key], numeric: num };
							});

						rcodeEntries.sort(function (a, b) {
							if (b.numeric === a.numeric) {
								if (a.key < b.key) return -1;
								if (a.key > b.key) return 1;
								return 0;
							}
							return b.numeric - a.numeric;
						});

						rcodeEntries.forEach(function (entry) {
							var key = entry.key;
							var val = entry.value;
							var row = document.createElement('tr');

							var blankCell = document.createElement('td');
							blankCell.textContent = '';
							var labelCell = document.createElement('td');
							labelCell.textContent = key.toLowerCase();
							var parts = getNumberParts(val);
							var countIntCell = document.createElement('td');
							countIntCell.className = 'fh-num-int';
							countIntCell.textContent = parts.intPart;
							var countDecCell = document.createElement('td');
							countDecCell.className = 'fh-num-dec';
							countDecCell.textContent = parts.decPart;
							row.appendChild(blankCell);
							row.appendChild(labelCell);
							row.appendChild(countIntCell);
							row.appendChild(countDecCell);
							tbody.appendChild(row);
						});
					} else if (!rcodeKeys.length) {
						var outcomes = rowData.outcomes || {};
						var outcomeKeys = Object.keys(outcomes);
						var onlySuccess =
							outcomeKeys.length === 1 && outcomeKeys[0] === 'success';
						if (!onlySuccess) {
							var outcomeEntries = outcomeKeys.map(function (key) {
								var num = Number(outcomes[key]);
								if (!isFinite(num)) {
									num = 0;
								}
								return { key: key, value: outcomes[key], numeric: num };
							});

							outcomeEntries.sort(function (a, b) {
								if (b.numeric === a.numeric) {
									if (a.key < b.key) return -1;
									if (a.key > b.key) return 1;
									return 0;
								}
								return b.numeric - a.numeric;
							});

							outcomeEntries.forEach(function (entry) {
								var key = entry.key;
								var val = entry.value;
								var row = document.createElement('tr');

								var blankCell = document.createElement('td');
								blankCell.textContent = '';
								var outcomeCell = document.createElement('td');
								outcomeCell.textContent = key;
								var parts = getNumberParts(val);
								var countIntCell = document.createElement('td');
								countIntCell.className = 'fh-num-int';
								countIntCell.textContent = parts.intPart;
								var countDecCell = document.createElement('td');
								countDecCell.className = 'fh-num-dec';
								countDecCell.textContent = parts.decPart;

								row.appendChild(blankCell);
								row.appendChild(outcomeCell);
								row.appendChild(countIntCell);
								row.appendChild(countDecCell);
								tbody.appendChild(row);
							});
						}
					}
				});

				table.appendChild(tbody);
				group.appendChild(table);
				statsGroupsEl.appendChild(group);
			}

			function appendUpstreamQtypesGroup(upstreamQtypes) {
				if (!upstreamQtypes || typeof upstreamQtypes !== 'object') {
					return;
				}
				var upstreamIds = Object.keys(upstreamQtypes);
				if (!upstreamIds.length) {
					return;
				}

				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Upstreams by Query type';
				heading.title = 'Per-upstream totals with breakdown by DNS query type (A, AAAA, PTR, etc.).';
				group.appendChild(heading);

				var table = document.createElement('table');
				table.className = 'fh-table fh-table-upstreams';
				var tbody = document.createElement('tbody');

				var upstreamRows = [];
				upstreamIds.forEach(function (upstreamId) {
					var qmap = upstreamQtypes[upstreamId];
					if (!qmap || typeof qmap !== 'object') {
						qmap = {};
					}
					var qtypes = Object.keys(qmap);
					if (!qtypes.length) {
						return;
					}
					var total = 0;
					qtypes.forEach(function (qt) {
						var val = Number(qmap[qt]);
						if (!isFinite(val)) {
							val = 0;
						}
						total += val;
					});
					upstreamRows.push({
						id: upstreamId,
						qtypes: qmap,
						qtypeKeys: qtypes,
						total: total,
					});
				});

				if (!upstreamRows.length) {
					return;
				}

				upstreamRows.sort(function (a, b) {
					if (b.total === a.total) {
						if (a.id < b.id) return -1;
						if (a.id > b.id) return 1;
						return 0;
					}
					return b.total - a.total;
				});

				upstreamRows.forEach(function (rowData) {
					var upstreamId = rowData.id;
					var total = rowData.total;
					var qtypes = rowData.qtypes || {};
					var qtypeKeys = rowData.qtypeKeys || [];

					var mainRow = document.createElement('tr');
					var mainUpstreamCell = document.createElement('td');
					mainUpstreamCell.textContent = upstreamId;
					var mainBlankCell = document.createElement('td');
					mainBlankCell.textContent = '';
					var mainTotalParts = getNumberParts(total);
					var mainTotalIntCell = document.createElement('td');
					mainTotalIntCell.className = 'fh-num-int';
					mainTotalIntCell.textContent = mainTotalParts.intPart;
					var mainTotalDecCell = document.createElement('td');
					mainTotalDecCell.className = 'fh-num-dec';
					mainTotalDecCell.textContent = mainTotalParts.decPart;
					mainRow.appendChild(mainUpstreamCell);
					mainRow.appendChild(mainBlankCell);
					mainRow.appendChild(mainTotalIntCell);
					mainRow.appendChild(mainTotalDecCell);
					tbody.appendChild(mainRow);

					var qtypeEntries = qtypeKeys.map(function (qt) {
						var num = Number(qtypes[qt]);
						if (!isFinite(num)) {
							num = 0;
						}
						return { key: qt, value: qtypes[qt], numeric: num };
					});

					qtypeEntries.sort(function (a, b) {
						if (b.numeric === a.numeric) {
							if (a.key < b.key) return -1;
							if (a.key > b.key) return 1;
							return 0;
						}
						return b.numeric - a.numeric;
					});

					qtypeEntries.forEach(function (entry) {
						var qt = entry.key;
						var val = entry.value;
						var row = document.createElement('tr');

						var blankCell = document.createElement('td');
						blankCell.textContent = '';
						var labelCell = document.createElement('td');
						labelCell.textContent = qt;
						var parts = getNumberParts(val);
						var countIntCell = document.createElement('td');
						countIntCell.className = 'fh-num-int';
						countIntCell.textContent = parts.intPart;
						var countDecCell = document.createElement('td');
						countDecCell.className = 'fh-num-dec';
						countDecCell.textContent = parts.decPart;

						row.appendChild(blankCell);
						row.appendChild(labelCell);
						row.appendChild(countIntCell);
						row.appendChild(countDecCell);
						tbody.appendChild(row);
					});
				});

				table.appendChild(tbody);
				group.appendChild(table);
				statsGroupsEl.appendChild(group);
			}

			function appendSystemGroup(system) {
				if (!system || typeof system !== 'object') {
					return;
				}
				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'System';
				group.appendChild(heading);

				var dl = document.createElement('dl');
				dl.className = 'fh-kv-list';

				var memTotal = system.memory_total_bytes;
				var memTotalUsed = system.memory_used_bytes;
				var memTotalAvail = system.memory_available_bytes;
				var memTotalFree = system.memory_free_bytes;

				function addMemRow(label, value) {
					if (value == null) {
						return;
					}
					var dt = document.createElement('dt');
					dt.textContent = label;
					var dd = document.createElement('dd');
					if (value === '') {
						dd.textContent = '';
					} else {
						dd.textContent = formatBytes(value);
					}
					dl.appendChild(dt);
					dl.appendChild(dd);
				}

				addMemRow('Total Memory', memTotal);
				addMemRow('Memory used', memTotalUsed);
				addMemRow('Free Memory', memTotalFree);
				addMemRow('Memory available', memTotalAvail);

				var loadKeys = ['load_1m', 'load_5m', 'load_15m'];
				loadKeys.forEach(function (key) {
					if (system[key] == null) {
						return;
					}
					var dt = document.createElement('dt');
					dt.textContent = key.replace('_', ' ');
					var dd = document.createElement('dd');
					dd.textContent = formatNumber(system[key]);
					dl.appendChild(dt);
					dl.appendChild(dd);
				});


				group.appendChild(dl);

				statsGroupsEl.appendChild(group);
			}

			function appendProcessGroup(system) {
				if (!system || typeof system !== 'object') {
					return;
				}
				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Process';
				group.appendChild(heading);

				var dl = document.createElement('dl');
				dl.className = 'fh-kv-list';

				var processUsed = system.process_rss_bytes;
				var processCpuPercent = system.process_cpu_percent;
				var processOpenFiles = system.process_open_files_count;
				var processConnections = system.process_connections_count;

				function addProcessRow(label, value) {
					var dt = document.createElement('dt');
					dt.textContent = label;
					var dd = document.createElement('dd');
					dd.textContent = value;
					dl.appendChild(dt);
					dl.appendChild(dd);
				}

				addProcessRow('Foghorn Memory use', formatBytes(processUsed));
				addProcessRow('Process CPU %', processCpuPercent + " %");
				addProcessRow('Process open files', processOpenFiles);
				addProcessRow('Process connections', processConnections);

				group.appendChild(dl);

				statsGroupsEl.appendChild(group);
			}

			function appendQtypeTopDomains(qtypeQnames) {
				if (!qtypeQnames || typeof qtypeQnames !== 'object') {
					return;
				}
				var qtypes = Object.keys(qtypeQnames).sort();
				qtypes.forEach(function (qt) {
					var entries = qtypeQnames[qt];
					if (!entries || !Array.isArray(entries) || !entries.length) {
						return;
					}
					// All qtype-based "Top <qt> Domains" lists go to the right-hand pane when available.
					var target = statsGroupsRightEl || statsGroupsEl;
					appendTopListGroup('Top ' + qt + ' Requests', entries, target);
				});
			}

			function appendRcodeTopDomains(rcodeDomains) {
				if (!rcodeDomains || typeof rcodeDomains !== 'object') {
					return;
				}
				var rcodes = Object.keys(rcodeDomains).sort();
				rcodes.forEach(function (rc) {
					var entries = rcodeDomains[rc];
					if (!entries || !Array.isArray(entries) || !entries.length) {
						return;
					}
					// Selected rcodes (NOERROR, NXDOMAIN, REFUSED, SERVFAIL) go to the right-hand pane.
					var isRightRcode = rc === 'NOERROR' || rc === 'NXDOMAIN' || rc === 'REFUSED' || rc === 'SERVFAIL';
					var target = isRightRcode && statsGroupsRightEl ? statsGroupsRightEl : statsGroupsEl;
					appendTopListGroup('Top ' + rc + ' Domains', entries, target);
				});
			}

			function appendRcodeTopSubdomains(rcodeSubdomains) {
				if (!rcodeSubdomains || typeof rcodeSubdomains !== 'object') {
					return;
				}
				var rcodes = Object.keys(rcodeSubdomains).sort();
				rcodes.forEach(function (rc) {
					var entries = rcodeSubdomains[rc];
					if (!entries || !Array.isArray(entries) || !entries.length) {
						return;
					}
					// NXDOMAIN and NOERROR subdomain lists go to the right-hand pane.
					var isRightRcode = rc === 'NXDOMAIN' || rc === 'NOERROR';
					var target = isRightRcode && statsGroupsRightEl ? statsGroupsRightEl : statsGroupsEl;
					appendTopListGroup('Top ' + rc + ' Subdomains', entries, target);
				});
			}

			function appendUpstreamStatusGroup(status) {
				if (!status || typeof status !== 'object') {
					return;
				}
				var items = status.items;
				if (!items || !Array.isArray(items) || !items.length) {
					return;
				}
				var container = statsGroupsEl || statsGroupsRightEl;
				if (!container) {
					return;
				}
				var group = document.createElement('section');
				group.className = 'fh-stats-group';

				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Upstream health';
				group.appendChild(heading);

				var metaP = document.createElement('p');
				metaP.className = 'fh-pane-help';
				metaP.textContent = 'Strategy: ' + (status.strategy || 'failover') +
					', max concurrent: ' + (status.max_concurrent != null ? status.max_concurrent : 1);
				group.appendChild(metaP);

				var table = document.createElement('table');
				table.className = 'fh-table fh-table-upstreams';
				var thead = document.createElement('thead');
				var headRow = document.createElement('tr');
				['Upstream', 'State', 'Failures', 'Backoff (s)'].forEach(function (label) {
					var th = document.createElement('th');
					th.textContent = label;
					th.style.textAlign = 'left';
					headRow.appendChild(th);
				});
				thead.appendChild(headRow);
				table.appendChild(thead);

				var tbody = document.createElement('tbody');
				items.forEach(function (item) {
					if (!item || typeof item !== 'object') {
						return;
					}
					var id = item.id || '';
					var state = item.state || 'up';
					var failCount = item.fail_count != null ? item.fail_count : 0;
					var backoffText = '';
					if (item.down_until) {
						var nowMs = Date.now();
						var untilMs = Number(item.down_until) * 1000;
						var remainingMs = untilMs - nowMs;
						if (remainingMs > 0) {
							backoffText = (remainingMs / 1000).toFixed(1);
						}
					}
					var tr = document.createElement('tr');
					var tdId = document.createElement('td');
					tdId.textContent = id;
					var tdState = document.createElement('td');
					tdState.textContent = state;
					var tdFail = document.createElement('td');
					tdFail.textContent = String(failCount);
					var tdBackoff = document.createElement('td');
					tdBackoff.textContent = backoffText;
					tr.appendChild(tdId);
					tr.appendChild(tdState);
					tr.appendChild(tdFail);
					tr.appendChild(tdBackoff);
					tbody.appendChild(tr);
				});

				table.appendChild(tbody);
				group.appendChild(table);

				// Try to insert directly after the "Upstreams" block when present so
				// that health details visually follow aggregate upstream stats.
				var anchor = null;
				var sections = container.querySelectorAll('.fh-stats-group');
				sections.forEach(function (sec) {
					if (anchor !== null) {
						return;
					}
					var h = sec.querySelector('h3');
					if (h && h.textContent === 'Upstreams') {
						anchor = sec;
					}
				});
				if (anchor && anchor.parentNode === container) {
					if (anchor.nextSibling) {
						container.insertBefore(group, anchor.nextSibling);
					} else {
						container.appendChild(group);
					}
				} else {
					container.appendChild(group);
				}
			}

			function renderStats(data) {
				clearStatsGroups();

				if (!data || typeof data !== 'object') {
					statsRawEl.textContent = 'No statistics payload returned from /stats';
					return;
				}

				if (data.status === 'disabled') {
					var disabledGroup = document.createElement('section');
					disabledGroup.className = 'fh-stats-group';
					var heading = document.createElement('h3');
					heading.className = 'fh-stats-group-title';
					heading.textContent = 'Status';
					disabledGroup.appendChild(heading);
					var p = document.createElement('p');
					p.className = 'fh-pane-help';
					p.textContent = 'Statistics are disabled for this server instance.';
					disabledGroup.appendChild(p);
					statsGroupsEl.appendChild(disabledGroup);
					statsRawEl.textContent = pretty(data);
					return;
				}

				// Prefer a created_at field from meta when present, falling back to
				// a top-level created_at. Always format as "YYYY-MM-DD HH:MM:SS".
				var rawCreatedAt = null;
				if (data.meta && typeof data.meta === 'object' && data.meta.created_at != null) {
					rawCreatedAt = data.meta.created_at;
				} else if (data.created_at != null) {
					rawCreatedAt = data.created_at;
				}
				var createdFormatted = rawCreatedAt != null ? formatTimestamp(rawCreatedAt) : null;

				var meta = {};
				if (data.meta && typeof data.meta === 'object') {
					meta = data.meta;
					delete meta.server_time;
					if (createdFormatted !== null) {
						meta.created_at = createdFormatted;
					}
					if (meta.uptime !== undefined && meta.uptime !== null) {
						meta.uptime = formatDurationSeconds(meta.uptime);
					}
				}

				// Ensure unique client/domain counts live in Meta, not Totals.
				if (data.uniques && typeof data.uniques === 'object') {
					if (data.uniques.clients != null && meta.clients == null) {
						meta.clients = data.uniques.clients;
					}
					if (data.uniques.domains != null && meta.domains == null) {
						meta.domains = data.uniques.domains;
					}
				}

				if (Object.keys(meta).length) {
					// Rebuild meta mapping so that clients/domains appear last in the
					// Meta box for readability.
					var metaForDisplay = {};
					Object.keys(meta).forEach(function (key) {
						if (key === 'clients' || key === 'domains') {
							return;
						}
						metaForDisplay[key] = meta[key];
					});
					if (meta.clients != null) {
						metaForDisplay.clients = meta.clients;
					}
					if (meta.domains != null) {
						metaForDisplay.domains = meta.domains;
					}
					appendDictGroup('Meta', metaForDisplay);
				}

				// Show per-process stats immediately after Meta so they stay visually
				// grouped near core host details.
				appendProcessGroup(data.system);

				// For Totals, hide certain internal-pre cache counters from the UI and
				// peel off DNSSEC-specific counters into their own mapping.
				var totalsForDisplay = {};
				var dnssecTotalsFromTotals = {};
				if (data.totals && typeof data.totals === 'object') {
					Object.keys(data.totals).forEach(function (key) {
						if (
							key === 'cache_deny_pre' ||
							key === 'cache_override_pre' ||
							key === 'cache_null'
						) {
							return;
						}
						if (key.indexOf('dnssec_') === 0) {
							dnssecTotalsFromTotals[key] = data.totals[key];
							return;
						}
						totalsForDisplay[key] = data.totals[key];
					});
				}

				// Surface unique client/domain counts only via Meta; Totals intentionally
				// omits clients/domains so they are not duplicated.
				appendDictGroup('Totals', totalsForDisplay);

				// Prefer a dedicated dnssec object from the API when present; fall
				// back to DNSSEC counters discovered under totals.
				var dnssecMapping = null;
				if (data.dnssec && typeof data.dnssec === 'object') {
					dnssecMapping = data.dnssec;
				} else if (dnssecTotalsFromTotals && Object.keys(dnssecTotalsFromTotals).length) {
					dnssecMapping = dnssecTotalsFromTotals;
				}
				if (dnssecMapping && Object.keys(dnssecMapping).length) {
					appendDictGroup('DNSSEC', dnssecMapping);
				}

				appendUpstreamsGroup(data.upstreams || {}, data.upstream_rcodes || {});
				appendDictGroup('Query types', data.qtypes || {});
				appendDictGroup('Response codes', data.rcodes || {});
				appendDictGroup('Recent latency', data.latency_recent || {});
				appendDictGroup('Latency', data.latency || {});

				appendTopListGroup('Top Client', data.top_clients || []);
				appendTopListGroup('Top Domains', data.top_domains || [], statsGroupsRightEl || statsGroupsEl);
				appendTopListGroup('Top Sub Domains', data.top_subdomains || [], statsGroupsRightEl || statsGroupsEl);
				// Cache hit/miss lists live in the right-hand pane when available.
				appendTopListGroup('Top Cache Hit Domains', data.cache_hit_domains || [], statsGroupsRightEl || statsGroupsEl);
				appendTopListGroup('Top Cache Miss Domains', data.cache_miss_domains || [], statsGroupsRightEl || statsGroupsEl);
				appendTopListGroup('Top Cache Hit Subdomains', data.cache_hit_subdomains || [], statsGroupsRightEl || statsGroupsEl);
				appendTopListGroup('Top Cache Miss Subdomains', data.cache_miss_subdomains || [], statsGroupsRightEl || statsGroupsEl);

				// Per-qtype top domains (qnames) for common query types.
				appendQtypeTopDomains(data.qtype_qnames || {});
				// Per-rcode top base domains.
				appendRcodeTopDomains(data.rcode_domains || {});
				// Per-rcode top base domains for subdomain-only traffic.
				appendRcodeTopSubdomains(data.rcode_subdomains || {});


				if (data.system) {
					appendSystemGroup(data.system);
				}

				statsRawEl.textContent = pretty(data);
			}

			function loadStats() {
				fetchJson('/api/v1/stats')
					.then(function (data) {
						renderStats(data);
						return fetchJson('/api/v1/upstream_status')
							.then(function (ustatus) {
								appendUpstreamStatusGroup(ustatus);
							})
							.catch(function () {
								// Upstream status is optional; ignore errors here.
							});
					})
					.catch(function (err) {
						statsRawEl.textContent = 'Failed to load statistics: ' + err.message;
					});
			}

			function renderDockerHostsSummary(root, summary) {
				if (!root) {
					return;
				}
				root.textContent = '';
				summary = summary || {};
				var group = document.createElement('section');
				group.className = 'fh-stats-group';
				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Summary';
				group.appendChild(heading);
				var dl = document.createElement('dl');
				dl.className = 'fh-kv-list';
				function addRow(label, value) {
					var dt = document.createElement('dt');
					dt.textContent = label;
					var dd = document.createElement('dd');
					dd.textContent = value;
					dl.appendChild(dt);
					dl.appendChild(dd);
				}
				var total = summary.total_containers != null ? summary.total_containers : 0;
				addRow('Containers', formatNumber(total));
				var eps = Array.isArray(summary.endpoints) ? summary.endpoints.length : 0;
				addRow('Endpoints', formatNumber(eps));
				if (summary.reload_interval != null) {
					addRow('Reload interval (s)', formatNumber(summary.reload_interval));
				}
				group.appendChild(dl);
				root.appendChild(group);
			}

			function renderDockerHostsTable(root, containers) {
				if (!root) {
					return;
				}
				root.textContent = '';
				containers = Array.isArray(containers) ? containers : [];
				var showHash = dockerShowHashEl && dockerShowHashEl.checked;
				var group = document.createElement('section');
				group.className = 'fh-stats-group';
				var heading = document.createElement('h3');
				heading.className = 'fh-stats-group-title';
				heading.textContent = 'Containers';
				group.appendChild(heading);
				if (!containers.length) {
					var p = document.createElement('p');
					p.className = 'fh-pane-help';
					p.textContent = 'No containers discovered by DockerHosts.';
					group.appendChild(p);
					root.appendChild(group);
					return;
				}
				var table = document.createElement('table');
				table.className = 'fh-table fh-table-upstreams';
				var thead = document.createElement('thead');
				var hrow = document.createElement('tr');
				['Name', 'IPv4', 'IPv6', 'TXT / Info'].forEach(function (label) {
					var th = document.createElement('th');
					th.textContent = label;
					hrow.appendChild(th);
				});
				thead.appendChild(hrow);
				table.appendChild(thead);
				var tbody = document.createElement('tbody');
				var MAX_NAME = 40;
				var MAX_IP = 40;
				var MAX_TXT = 80;
				function truncateCell(td, full, max) {
					var text = typeof full === 'string' ? full : String(full || '');
					if (text.length > max) {
						td.textContent = text.slice(0, max - 1) + '\u2026';
						td.title = text;
					} else {
						td.textContent = text;
					}
				}
				containers.forEach(function (c) {
					if (!c || typeof c !== 'object') {
						return;
					}
					// Hide hash-like hostnames when the toggle is off. We rely on
					// the backend to sort hash-style names to the bottom already; the
					// toggle simply filters them out of the visible table by default.
					if (!showHash && typeof c.name === 'string') {
						var token = c.name.split('.')[0].toLowerCase().trim();
						if (token && token.length >= 12 && token.length <= 64) {
							var allHex = true;
							for (var i = 0; i < token.length; i++) {
								var ch = token.charAt(i);
								if ('0123456789abcdef'.indexOf(ch) === -1) {
									allHex = false;
									break;
								}
							}
							if (allHex) {
								return;
							}
						}
					}
					var tr = document.createElement('tr');
					var tdName = document.createElement('td');
					truncateCell(tdName, c.name || '', MAX_NAME);
					var tdV4 = document.createElement('td');
					var fullV4 = Array.isArray(c.ipv4) ? c.ipv4.join(', ') : '';
					truncateCell(tdV4, fullV4, MAX_IP);
					var tdV6 = document.createElement('td');
					var fullV6 = Array.isArray(c.ipv6) ? c.ipv6.join(', ') : '';
					truncateCell(tdV6, fullV6, MAX_IP);
					var tdTxt = document.createElement('td');
					var txts = Array.isArray(c.txt) ? c.txt : [];
					var fullTxt = txts.join(' | ');
					truncateCell(tdTxt, fullTxt, MAX_TXT);
					tr.appendChild(tdName);
					tr.appendChild(tdV4);
					tr.appendChild(tdV6);
					tr.appendChild(tdTxt);
					tbody.appendChild(tr);
				});
				table.appendChild(tbody);
				group.appendChild(table);
				root.appendChild(group);
			}

			function loadDockerHosts() {
				var summaryEl = document.getElementById('docker-hosts-summary');
				var tableEl = document.getElementById('docker-hosts-table');
				if (!summaryEl || !tableEl) {
					return;
				}
				summaryEl.textContent = '';
				tableEl.textContent = '';
				var url = '/api/v1/plugins/' + encodeURIComponent(DOCKER_HOSTS_PLUGIN_NAME) + '/docker_hosts';
				fetchJson(url)
					.then(function (payload) {
						var data = payload && payload.data ? payload.data : {};
						renderDockerHostsSummary(summaryEl, data.summary || {});
						renderDockerHostsTable(tableEl, data.containers || []);
					})
					.catch(function (err) {
						var group = document.createElement('section');
						group.className = 'fh-stats-group';
						var pre = document.createElement('pre');
						pre.className = 'fh-pre fh-pre-compact';
						pre.textContent = 'Failed to load DockerHosts data: ' + err.message;
						group.appendChild(pre);
						tableEl.appendChild(group);
					});
			}

			function loadDiskConfig(raw) {
				if (raw === undefined) {
					raw = 0;
				}
				var url = '/api/v1/config';
				if (raw !== 0 || isEditing) {
					url += '/raw';
				}
				return fetch(url, { cache: 'no-store' })
					.then(function (resp) {
						if (!resp.ok) {
							throw new Error('HTTP ' + resp.status + ' from ' + url);
						}
						return resp.text();
					})
					.then(function (text) {
						if (raw !== 0 || isEditing) {
							// Raw on-disk YAML for edit mode.
							lastDiskRawYaml = text;
							return { raw_yaml: text };
						}
						// View mode: text is already redacted YAML from /config.
						configOutputEl.textContent = text;
						return { raw_yaml: text };
					})
					.catch(function (err) {
						if (!isEditing) {
							configOutputEl.textContent = 'Failed to load on-disk config: ' + err.message;
						}
						throw err;
					});
			}

			function refreshDiskConfigView() {
				loadDiskConfig();
			}

			function enterEditMode() {
				if (currentSource !== 'disk') {
					return;
				}
				isEditing = true;
				actionsView.hidden = true;
				actionsEdit.hidden = false;
				if (warningEl) {
					warningEl.hidden = false;
				}
				configViewContainer.hidden = true;
				configEditContainer.hidden = false;
				setMessage('Validating configuration before editing...', 'info');

				loadDiskConfig(1)
					.then(function (data) {
						var rawYaml = data && data.raw_yaml ? data.raw_yaml : (lastDiskRawYaml || '');
						var cfgObj = {};
						try {
							if (window.jsyaml && typeof window.jsyaml.load === 'function') {
								cfgObj = window.jsyaml.load(rawYaml) || {};
							} else {
								cfgObj = {};
							}
						} catch (e) {
							throw new Error('Failed to parse YAML: ' + e.message);
						}
						lastDiskConfigObj = cfgObj;
						return validateConfigObjectForEdit(cfgObj).then(function () {
							return rawYaml;
						});
					})
					.then(function (rawYaml) {
						configEditorEl.value = rawYaml || '';
						setMessage('Editing on-disk config, save will overwrite!', 'info');
					})
					.catch(function (err) {
						setMessage('Cannot enter edit mode: ' + err.message, 'error');
						exitEditMode(false);
					});
			}

			function exitEditMode(refresh) {
				isEditing = false;
				actionsEdit.hidden = true;
				actionsView.hidden = currentSource !== 'disk';
				if (warningEl) {
					warningEl.hidden = true;
				}
				configEditContainer.hidden = true;
				configViewContainer.hidden = false;
				if (refresh && currentSource === 'disk') {
					loadDiskConfig();
				}
			}

			function saveConfig() {
				setMessage('', null);
				var yamlText = configEditorEl.value || '';
				if (!yamlText.trim()) {
					setMessage('Configuration text is empty; refusing to save.', 'error');
					return;
				}

				if (!window.confirm('Are you sure you want to overwrite config.yaml and request a restart via SIGHUP?')) {
					return;
				}

				fetch('/api/v1/config/save', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({ raw_yaml: yamlText }),
				})
					.then(function (resp) {
						if (!resp.ok) {
							return resp.text().then(function (text) {
								throw new Error('HTTP ' + resp.status + ': ' + text);
							});
						}
						return resp.json().catch(function () {
							return {};
						});
					})
					.then(function (data) {
						setMessage('Configuration saved; restart requested via SIGHUP. Path: ' + (data.path || ''), 'success');
						exitEditMode(true);
						loadDiskConfig();
						loadStats();
					})
					.catch(function (err) {
						setMessage('Failed to save configuration: ' + err.message, 'error');
					});
			}

			function applyTheme(theme) {
				var next = theme === 'light' ? 'light' : 'dark';
				root.setAttribute('data-theme', next);
				if (logoEl) {
					if (next === 'dark') {
						logoEl.src = '/transparent-white-logo.png';
					} else {
						logoEl.src = '/transparent-logo.png';
					}
				}
				try {
					if (window.localStorage) {
						localStorage.setItem('foghorn-theme', next);
					}
				} catch (e) {}

				if (next === 'dark') {
					btnThemeDark.classList.add('fh-theme-btn-active');
					btnThemeDark.setAttribute('aria-checked', 'true');
					btnThemeLight.classList.remove('fh-theme-btn-active');
					btnThemeLight.setAttribute('aria-checked', 'false');
				} else {
					btnThemeLight.classList.add('fh-theme-btn-active');
					btnThemeLight.setAttribute('aria-checked', 'true');
					btnThemeDark.classList.remove('fh-theme-btn-active');
					btnThemeDark.setAttribute('aria-checked', 'false');
				}
			}

			function detectDockerTabVisibility() {
				if (!btnTabDocker && !pageDocker) {
					return;
				}
				fetchJson('/api/v1/config.json')
					.then(function (payload) {
						var cfg = payload && payload.config ? payload.config : payload;
						if (!cfg || typeof cfg !== 'object') {
							return;
						}
						var plugins = cfg.plugins;
						if (!Array.isArray(plugins)) {
							return;
						}
						var show = plugins.some(function (spec) {
							if (!spec || typeof spec !== 'object') {
								return false;
							}
							var moduleName = String(spec.module || '').toLowerCase();
							if (!moduleName) {
								return false;
							}
							// Support both full and short module forms.
							if (
								moduleName !== 'docker-hosts' &&
								moduleName !== 'foghorn.plugins.docker-hosts'
							) {
								return false;
							}
							var specEnabled = spec.enabled;
							var cfgEnabled = spec.config && spec.config.enabled;
							var enabled = true;
							if (specEnabled !== undefined && specEnabled !== null) {
								enabled = Boolean(specEnabled);
							}
							if (cfgEnabled !== undefined && cfgEnabled !== null) {
								enabled = Boolean(cfgEnabled);
							}
							return enabled;
						});
						if (!show) {
							if (btnTabDocker) {
								btnTabDocker.style.display = 'none';
							}
							if (pageDocker) {
								pageDocker.style.display = 'none';
							}
						}
					})
					.catch(function () {
						// On failure, leave Docker tab visible; other parts of the UI still work.
					});
			}

			function applyTab(tab) {
				var isStats = tab === 'stats';
				var isEdit = tab === 'edit';
				var isDocker = tab === 'docker';

				if (page1) {
					// When Stats is selected, page1 should be hidden and page2 shown.
					page1.style.display = isStats ? 'none' : (isEdit ? '' : 'none');
				}
				if (page2) {
					page2.style.display = isStats ? '' : 'none';
				}
				if (pageDocker) {
					pageDocker.style.display = isDocker ? '' : 'none';
				}

				if (btnTabStats) {
					if (isStats) {
						btnTabStats.classList.add('fh-theme-btn-active');
						btnTabStats.setAttribute('aria-selected', 'true');
					} else {
						btnTabStats.classList.remove('fh-theme-btn-active');
						btnTabStats.setAttribute('aria-selected', 'false');
					}
				}
				if (btnTabEdit) {
					if (isEdit) {
						btnTabEdit.classList.add('fh-theme-btn-active');
						btnTabEdit.setAttribute('aria-selected', 'true');
					} else {
						btnTabEdit.classList.remove('fh-theme-btn-active');
						btnTabEdit.setAttribute('aria-selected', 'false');
					}
				}
				if (btnTabDocker) {
					if (isDocker) {
						btnTabDocker.classList.add('fh-theme-btn-active');
						btnTabDocker.setAttribute('aria-selected', 'true');
					} else {
						btnTabDocker.classList.remove('fh-theme-btn-active');
						btnTabDocker.setAttribute('aria-selected', 'false');
					}
				}
			}

			//// Event bindings

			// Enter Edit Mode
			btnEdit.addEventListener('click', function () {
				enterEditMode();
			});

			// Cancel Edit
			btnCancel.addEventListener('click', function () {
				exitEditMode(true);
				setMessage('Edit cancelled.', 'info');
			});

			// Save config
			btnSave.addEventListener('click', function () {
				saveConfig();
			});

			// Theme control
			btnThemeDark.addEventListener('click', function () {
				applyTheme('dark');
			});
			btnThemeLight.addEventListener('click', function () {
				applyTheme('light');
			});

			// Tabs control
			if (btnTabStats) {
				btnTabStats.addEventListener('click', function () {
					applyTab('stats');
				});
			}
			if (btnTabEdit) {
				btnTabEdit.addEventListener('click', function () {
					applyTab('edit');
				});
			}
			if (btnTabDocker) {
				btnTabDocker.addEventListener('click', function () {
					applyTab('docker');
					loadDockerHosts();
				});
			}
			if (dockerShowHashEl) {
				dockerShowHashEl.checked = false;
				dockerShowHashEl.addEventListener('change', function () {
					// Re-render the current snapshot when the toggle changes.
					var tableEl = document.getElementById('docker-hosts-table');
					if (!tableEl || !tableEl.firstChild) {
						// No data yet; next loadDockerHosts() will respect the flag.
						return;
					}
					// Easiest is to refetch; snapshot is cheap compared to Docker reload.
					loadDockerHosts();
				});
			}

			// Initial load
			var initialTheme = root.getAttribute('data-theme') || 'dark';
			applyTheme(initialTheme);
			applyTab('stats');
			loadStats();
			detectDockerTabVisibility();
			setInterval(loadStats, 15000);
			refreshDiskConfigView();
			})();
		</script>
</body>

</html>
